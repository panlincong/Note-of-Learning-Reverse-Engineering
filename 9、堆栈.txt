1、这里的堆栈和数据结构的堆栈没有关系，这里的堆栈是程序运行之前，操作系统给程序分配好的一块内存空间，虽然是已经分配好的，
但是依然要申请才能使用，如果超过这个地址空间，就会发生堆栈溢出。程序运行时的中间结果都临时保存在堆栈中，往堆栈里存数据时是从高地址到低地址的顺序。

2、往堆栈里面存入数据时，是从高地址到低地址，例如push eax后，首先会把eax中的数据存到ds:[esp]这个地址编号对应的内存单元，然后esp-4,指向更低的地址编号，告诉操作系统这块内存空间我用了。
所以可以看出往堆栈中写入数据时，是从高地址到低地址的顺序。在ollydbg中，我们可以看到，堆栈的地址存放在FS中，一般为7EFFDD000,
我们可以dd 7EFFDD000，显示如下内容：
7EFDD004  00190000  (top of thread's stack线程堆栈顶部)
7EFDD008  0018D000  (bottom of thread's stack线程堆栈底部)
其中7EFDD004 中存放的值00190000是堆栈的栈顶，7EFDD008 中的0018D000是栈底，而我们往堆栈存入数据时，是从00190000开始存的，逐渐往低地址存。
如果要看当前程序当前状态的堆栈地址，看esp的值就是

3、push指令(esp叫堆栈指针寄存器，记录当前程序的堆栈地址用到什么位置，指向栈顶)
push指令首先改变esp的值，然后把指定数据存入到esp指向的内存编号ds:[esp]中；
esp减去2或4(如果是16位寄存器，就减2,32位减4)，决定我们需要存入的数据的宽度多大，如果要存的是16位，esp只需减2，因为2个内存单元就可以了，所以地址编号减2，32位就减去4；
push指令可以等价位mov和sub：
例如 push eax，把eax的内容存入到堆栈，可以等价于 
sub esp, 4
mov dword ptr ds:[esp]，eax 
如果是push ax，因为ax是16位寄存器，mov要求操作数数据宽度一致，所以我们这里指定内存宽度为16位，即word
sub esp，2
mov word ptr ds:[esp]，ax
（注意这里esp-2不是减4）
格式：
push r16/r32
push 内存地址，把内存地址中的数据存入到堆栈
push 立即数

4、pop指令
pop指令用来把堆栈的数据取出来，存放到目标中，然后改变esp的值，pop指令执行后esp减2还是减4也是取决于接收数据的数据宽度；
pop指令是先复制当前esp指向的内存编号的内存单元的内容到目标操作数后，然后再改变esp的值，告诉操作系统这块内存空间我已经不用了，释放出去，但里面的数据依然还在。
pop eax等价于：
mov eax，ds:[esp]
add 4, esp
如果把32位的eax变成16位的ax
pop ax则等价于：
mov ax, ds:[esp]
add 2, esp
（这里是加2）
