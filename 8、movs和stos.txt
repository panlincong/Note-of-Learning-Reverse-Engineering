1、大端存储和小端存储
大端存储：高地址存低位数，低地址存高位数；
小端存储：高地址存高位数，低地址存低位数；

字符串传送指令：movs和stos
（movs指令执行完后，si和edi的值都要改变，是增还是减，由df标志位决定，如果df为0，则加；如果df为1，则减）
2、movs指令
movs指令用来把esi中的地址编号对应的内存单元的数据复制到edi中地址编号对应的内存里
movs byte ptr es:[edi], ds:[esi] 也可以简写为movsb
movs word ptr es:[edi], ds:[esi]  也可以简写为movsw
movs dword ptr es:[edi], ds:[esi]  也可以简写为movsd
把esi中存储的地址编号中的数据复制到edi中存储的地址编号的内存单元中，byte、word、dword指的是内存单元的宽度；
byte表示一个内存单元的宽度为1，因为一个内存单元是一个字节，word就是2个内存单元，dword即3个；
例如：
edi中存放的地址编号为0x18fe，esi是0x1800，
以编号为0x18fe开始的内存单元中存放的数据为0000 0000，
以编号为0x1800开始的内存单元中存放的数据为1122 3344，
执行完mov byte ptr es:[edi], ds:[esi]后，以编号为0x18fe开始的内存单元中的内容变为0000 0044,
并且esi会加一，变为0x1801，edi变成0x18ff；
再次执行mov byte ptr es:[edi], ds:[esi]，以编号为0x18fe开始的内存单元中的内容变为0000 3344，
esi加一，变为0x1802，edi变成0x1900；
（这里为什么以0x18fe的内存单元中内容变成0000 3344了呢？因为我们这里是按dword，即32位显示的，一次显示的是4个内存单元的内容，如果按byte显示，那么就是 00 00 33 44，
其中44就是编号0x18fe的内存单元存放的数据, 33就是编号0x18ff的内存单元存放的数据）
因为efl寄存器是一个状态寄存器，其中的dr的值决定了esi和edi执行movs后是加1还是减1(即地址编号前移或后移)，而移动多少，则由我们指定的内存单元宽度决定，
这里是byte，即字节，在一个内存单元之间进行赋值，所以每次移动1,如果是word，则每次移动4，如果是dword，则移动8；esi和edi是增还是减，由df位决定，
如果df位为0，则是加，如果为1，则为减；标志寄存器efl是32位，其中的每一位都=表示不同的含义；其中第10位是df位，下标从0开始。

3、stos指令（stos执行完后，edi的值自动改变，增减规则和movs一样）
stos指令用来向把eax/ax/al中的数据写入edi中的地址编号对应的内存单元中
stos byte ptr es:[edi]  可以简写为stosb
stos word ptr es:[edi]	可以简写为stosw
stos dword ptr es:[edi]	可以简写为stosd
至于是把eax还是ax或al中的数据复制到edi中，具体看操作数的数据宽度，如果是16位，就用ax，32位用eax，8位用al；
执行完指令后edi是加还是减，和movs指令一样，看具体的内存单元宽度和df值

总结：其实esi和edi的值的改变，是为了指向前面的或后面的内存单元，这样我们就可以对内存进行操作了。

4、rep指令
rep指令是重复执行某一个指令，其中执行的次数有ecx的值决定，注意ecx中存的值是16进制的
mov ecx， 10
rep stosb 重复执行stosb16次，因为16进制的10换成10进制就是16

